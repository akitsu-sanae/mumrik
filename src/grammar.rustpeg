use std::str;
use std::i64;

use super::expr::*;
use super::type_::Type;

type_ -> Type
  = variant_type
  / record_type
  / function_type

type_branch -> (String, Box<Type>)
  = label:identifier COLON ty:type_ COMMA? {
      (label, box ty)
  }

variant_type -> Type
  = branches:(BAR tag:identifier COLON ty:type_ COMMA? { (tag, box ty) })+ {
      Type::Variant(branches)
  }

record_type -> Type
  = LEFT_RECORD branches:type_branch* RIGHT_RECORD {
      Type::Record(branches)
  }

function_type -> Type
  = from:primitive_type ARROW to:function_type {
      Type::Function(box from, box to)
  }
  / primitive_type

primitive_type -> Type
  = name:identifier {
      Type::Primitive(name)
  }


pub expr -> Expr
  = __ e:type_alias { e }

type_alias -> Expr
  = TYPE name:identifier EQUAL ty:type_ after:expr {
      Expr::TypeAlias(name, box ty, box after)
  }
  / func_expr

func_expr -> Expr
  = FUNC name:identifier arg:identifier COLON arg_ty:type_ LEFT_BRACE body:let_expr RIGHT_BRACE after:expr {
      // func f arg: T = expr
      // => let f = func arg: T -> expr
      Expr::Let(name, box Expr::Lambda(arg, box arg_ty, box body), box after)
  }
  / REC FUNC name:identifier arg:identifier COLON arg_ty:type_ COLON ret_ty:type_ LEFT_BRACE body:let_expr RIGHT_BRACE after:expr {
      Expr::LetRec(name, box Type::Function(box arg_ty.clone(), box ret_ty), box Expr::Lambda(arg, box arg_ty, box body), box after)
  }
  / let_expr

let_expr -> Expr
  = LET name:identifier EQUAL init:inner_expr SEMICOLON  body:expr {
      Expr::Let(name, box init, box body)
  }
  / REC LET name:identifier COLON ty:type_ EQUAL init:inner_expr SEMICOLON  body:expr {
      Expr::LetRec(name, box ty, box init, box body)
  }
  / sequence_expr

sequence_expr -> Expr
  = e1:inner_expr SEMICOLON e2:sequence_expr {
      Expr::Sequence(box e1, box e2)
  }
  / inner_expr

inner_expr -> Expr
  = if_expr

if_expr -> Expr
  = IF cond:expr LEFT_BRACE tr:expr RIGHT_BRACE ELSE LEFT_BRACE fl:expr RIGHT_BRACE {
      Expr::If(box cond, box tr, box fl)
  }
  / match_expr

match_branch -> (String, String, Box<Expr>)
  = label:identifier name:identifier FAT_ARROW e:expr COMMA? {
      (label, name, box e)
  }

match_expr -> Expr
  = MATCH e:expr LEFT_BRACE branches:match_branch* RIGHT_BRACE {
      Expr::Match(box e, branches)
  }
  / binop_expr

binop_expr -> Expr
  = #infix<apply_expr> {
    #L l DOUBLE_EQUAL r { Expr::Equal(box l, box r) }
       l NOT_EQUAL r { Expr::NotEqual(box l, box r) }
    #L l LEFT_ANGLE_BRACKET r { Expr::LessThan(box l, box r) }
       l RIGHT_ANGLE_BRACKET r { Expr::GreaterThan(box l, box r) }
    #L l PLUS r { Expr::Add(box l, box r) }
       l MINUS r { Expr::Sub(box l, box r) }
    #L l STAR r { Expr::Mult(box l, box r) }
       l SLASH r { Expr::Div(box l, box r) }
}

apply_expr -> Expr
  = l:dot_expr r:apply_expr {
      Expr::Apply(box l, box r)
  }
  / dot_expr

dot_expr -> Expr
  = e:factor labels:(DOT id:identifier { id })* {
      labels.iter().fold(e, |acc, label| Expr::Dot(box acc, label.clone()))
  }

factor -> Expr
  = lambda_expr
  / number_expr
  / boolean_expr
  / unit_expr
  / println_expr
  / variant_expr
  / record_expr
  / variable_expr
  / paren_expr

lambda_expr -> Expr
  = FUNC name:identifier COLON ty:type_ FAT_ARROW body:expr {
      Expr::Lambda(name, box ty, box body)
  }

number_expr -> Expr
  = n:$([0-9]+) __ { Expr::Number(i64::from_str_radix(n, 10).unwrap()) }

boolean_expr -> Expr
  = TRUE { Expr::Bool(true) }
  / FALSE { Expr::Bool(false) }

unit_expr -> Expr
  = UNIT { Expr::Unit }

println_expr -> Expr
  = PRINTLN e:inner_expr { Expr::Println(box e) }

branch -> (String, Box<Expr>)
    = label:identifier EQUAL e:expr COMMA? {
        (label, box e)
    }

// Term::Add(hoge)
variant_expr -> Expr
  = ty:type_ DOUBLE_COLON label:identifier LEFT_PAREN e:expr RIGHT_PAREN  {
      Expr::Variant(label.clone(), box e, box ty)
  }

record_expr -> Expr
  = LEFT_RECORD branches:branch* RIGHT_RECORD {
      Expr::Record(branches)
  }

variable_expr -> Expr
  = name:identifier { Expr::Var(name.clone()) }

paren_expr -> Expr
  = LEFT_PAREN e:expr RIGHT_PAREN { e }

identifier -> String
  = s:$([a-zA-Z_][a-zA-Z0-9_]*) __ { s.to_string() }

__ = [ \n\t]*

PLUS = "+" __
MINUS = "-" __
EQUAL = "=" __
STAR = "*" __
SLASH = "/" __
PERCENT = "%" __
DOUBLE_EQUAL = "==" __
NOT_EQUAL = "/=" __
AT = "@" __
COMMA = "," __
DOT = "."
COLON = ":" __
DOUBLE_COLON = "::" __
SEMICOLON = ";" __
ARROW = "->" __
FAT_ARROW = "=>" __
LEFT_BRACE = "{" __
RIGHT_BRACE = "}" __
LEFT_PAREN = "(" __
RIGHT_PAREN = ")" __
LEFT_ANGLE_BRACKET = "<" __
RIGHT_ANGLE_BRACKET = ">" __
BAR = "|" __
LEFT_RECORD = "[*" __
RIGHT_RECORD = "*]" __

keyword<E> = E !([a-zA-Z0-9_]) __

LET = keyword<"let">
IF = keyword<"if">
ELSE = keyword<"else">
MATCH = keyword<"match">
PRINTLN = keyword<"println">
FUNC = keyword<"func">
REC = keyword<"rec">
AS = keyword<"as">
TYPE = keyword<"type">

TRUE = keyword<"true">
FALSE = keyword<"false">

UNIT = keyword<"unit">
