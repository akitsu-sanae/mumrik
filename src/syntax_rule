
use super::Expression;
use super::Function;
use super::Type;

space = [ \n\t]*

identifier -> String
    = [a-zA-Z_!?][a-zA-Z0-9_!?]* { match_str.to_string() }

#[export]
function -> Function
    = "func" space name: identifier space arg_name: identifier space ":" space t: type_ space "{" space e: expression space "}" space {
        Function{name: name, arg_name: arg_name, arg_type: box t, body: box e}
    }

#[export]
expression -> Expression
    = e: sequence_expression { e }

sequence_expression -> Expression
    = l:let_expression space ";" space r:sequence_expression space {
        Expression::Sequence(box l, box r)
    }
    / e: let_expression { e }

let_expression -> Expression
    = "let" space id: identifier space ":" space t: type_ space "=" space e: let_expression space {
        Expression::Let(id, box t, box e)
    }
    / e: add_expression { e }

add_expression -> Expression
    = l:mult_expression space "+" space r:add_expression space {
        Expression::Add(box l, box r)
    }
    / l:mult_expression space "-" space r:add_expression space {
        Expression::Sub(box l, box r)
    }
    / e: mult_expression { e }

mult_expression -> Expression
    = l:apply_expression space "*" space r:mult_expression space {
        Expression::Mult(box l, box r)
    }
    / e: apply_expression { e }

apply_expression -> Expression
    = l:dot_expression space "@" space r:apply_expression space {
        Expression::Apply(box l, box r)
    }
    / e: dot_expression { e }

dot_expression -> Expression
    = l:atomic_expression space "." space r:dot_expression space {
        Expression::Dot(box l, box r)
    }
    / e: atomic_expression { e }

atomic_expression -> Expression
    = e: number_literal { e }
    / e: identifier_expression { e }
    / e: lambda_expression { e }
    / "(" space e: expression space ")" space { e }

number_literal -> Expression
    = ("-"?)[0-9]+ {
        Expression::NumberLiteral(match_str.parse().unwrap())
    }

identifier_expression -> Expression
    = id:identifier {
        Expression::Identifier(id)
    }

lambda_expression -> Expression
    = "|" space id:identifier space ":" space t: type_ space "|" space "{" space e:expression space "}" space {
        Expression::Lambda(id, box t, box e)
    }

range_expression -> Expression
    = "{" space f:expression space "..." space l:expression space "}" space {
        Expression::Range(box f, box l)
    }


#[export]
type_ -> Type
    = t: union_type { t }

union_type -> Type
    = l: tuple_type space "+" space r: union_type space {
        Type::Union(box l, box r)
    }
    / t: tuple_type { t }

tuple_type -> Type
    = l: primary_type space "*" r: tuple_type space {
        Type::Tuple(box l, box r)
    }
    / t: primary_type { t }

primary_type -> Type
    = id: identifier space { Type::Primary(id) }


